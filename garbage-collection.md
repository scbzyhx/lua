#Lua——垃圾回收机制  

Lua 通过特定算法的垃圾回收机制实现自动内存管理。由于自动内存管理机制的存在，作为程序开发人员：  
<ul>
	<li>不需要关心对象的内存分配问题。</li>
	<li>不再使用对象时，除了将引用它的变量设为 nil，不需要主动释放对象。</li>
</ul>  
Lua 的垃圾回收器会不断运行去收集不能再被 Lua 程序访问的对象。  
所有的对象，包括表、userdata、函数、线程、字符串等由自动内存管理机制管理它们空间的分配和翻放。Lua 实现了一个增量标记清除收集器。它用两个数字控制垃圾回收周期，垃圾收集器暂停时间（garbage-collector pause） 和垃圾收集器步长倍增器（garbage-collector step multiplier）。其数值是以百分制计数的，即 100 内部表示 1。  

##垃圾收集器暂停时间 

该数值被用于控制垃圾收集器被 Lua 自动内存管理再次运行之前需要的等待时长。当其小于 100 时意味着收集器在新周期开始前不再等待。同样地，值越大垃圾回收器也就越慢，也就不那么主动。当其值 200 时，收集器在总使用内存数量达到原来的两倍时再开启新的周期。因此，根据程序不同的特征，可以通过修改该值使得程序达到最佳的性能。  

##垃圾收集器步长倍增器  

步长倍增器用于控制了收集器相对内存分配的速度。数值越大收集器工作越主动，值小于 100 会导致垃圾器永远不能结束  

##垃圾回收器相关函数  

作为开发人员，我们需要控制 Lua 的自动内存管理机制。我们可以使用下面的这些方法：  
<ul>
	<li>collectgarbage("collect")：运行一个完整的垃圾回收周期。</li>
	<li>collectgarbage("count")：返回当前程序使用的内存总量，以 KB 为单位。</li>
	<li>collectgarbage("restart")：如果垃圾回收器停止，则重新运行之。</li>
	<li>collectgarbage("setpause")：设置垃圾收集暂停时间变量的值，值由第二个参数指出（第二参数的值除以 100 后为赋予变量的值）。稍后，我们将详细讨论它的用法。</li>
	<li>collectgarbage("setsetmul")：设置垃圾收集器步长倍增器的值，第二个参数的含义与上同。</li>
	<li>collectgarbage("step")：运行。</li>
</ul>